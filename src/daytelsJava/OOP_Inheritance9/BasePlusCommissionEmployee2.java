package daytelsJava.OOP_Inheritance9;

public class BasePlusCommissionEmployee2 extends CommissionEmployee {
    private double baseSalary; // base salary per week


    public BasePlusCommissionEmployee2(String first, String last, String ssn, double sales, double rate, double salary) {
        super(first, last, ssn, sales, rate);//explicit (явный) call to superclass

        setBaseSalary(salary);// validate and store base salary
    }

    public void setBaseSalary(double salary) {
        if (salary >= 0.0) {
            this.baseSalary = salary;
        } else throw new IllegalArgumentException("Base salary must be >=0.0");
    }

    public double getBaseSalary() {
        return baseSalary;
    }

//    public double earnings() { // not allowed: grossSales and CommissionRate private in superclass
//        return baseSalary + (grossSales * CommissionRate);
//    }

    // return String representation of BasePlusCommissionEmployee
//   public static void main(String[] args) {// not allowed: grossSales and CommissionRate private in superclass
//        BasePlusCommissionEmployee employee = new BasePlusCommissionEmployee( // instantiate BasePlusCommissionEmployee object
//                "Bob", "Lewis", "333-33-3333", 5000, .04, 300);
//        // get base-salaried commission employee data
//        System.out.println(
//                "Employee information obtained by get methods: \n");
//        System.out.printf("%s %s\n", "First name is", employee.getFirstName());
//        System.out.printf("%s %s\n", "Last name is", employee.getLastName());
//        System.out.printf("%s %s\n", "Social security number is", employee.getSocialSecurityNumber());
//        System.out.printf("%s %.2f\n", "Gross sales is", employee.getGrossSales());
//        System.out.printf("%s %.2f\n", "Commission rate is", employee.getCommissionRate());
//        System.out.printf("%s %.2f\n", "Base salary is", employee.getBaseSalary());
//        employee.setBaseSalary(1000); // set base salary
//        System.out.printf("\n%s:\n\n%s\n", "Updated employee information obtained by toString", employee.toString());//явно вызовите метод toString, чтобы получить строковое представление объекта.
//
//    }

}
/*    Теперь мы переопределяем класс BasePlusCommissionEmployee (рис. 9.8), чтобы расширить класс CommissionEmployee
(рис. 9.4). Объект BasePlusCommissionEmployee является CommissionEmployee,
        поскольку наследование передает возможности класса CommissionEmployee. Класс
        BasePlus-CommissionEmployee также имеет переменную экземпляра baseSalary (рис. 9.8, строка 6).
        Ключевое слово расширяется (строка 4) указывает на наследование. BasePlusCommissionEmployee наследует
        Переменные и методы экземпляра Комиссионер, но только открытые
        и защищенные члены суперкласса непосредственно доступны в подклассе. Комиссионер
        конструктор не наследуется. Так, публичные сервисы BasePlusCommissionEmployee включают
        в себя его конструктор (строки 9-16), публичные методы, унаследованные от CommissionEmployee,
        а также методы setBaseSalary (строки 19-26), getBaseSalary (строки 29-32), заработок
        (строки 35-40) и toString (строки 43-53). Методы заработка и переопределяют метод toString
        соответствующие методы в классе Комиссионер, поскольку их версии суперкласса
        неправильно вычисляют заработок BasePlusCommissionEmployee или возвращают соответствующий
        Строковое представление. неявное Когда вы создаете объект BasePlusCommissionEmployee, он содержит все переменные экземпляра
        , объявленные в иерархии классов до этого момента, то есть переменные из классов Object, CommissionEmployee
        и BasePlusCommissionEmployee. Класс BasePlusCommissionEmployee
        не наследует конструктор класса CommissionEmployee. Однако класс BasePlus-
        Конструктор CommissionEmployee с шестью аргументами (строки 10-15) вызывает класс Commission-
        Конструктор с пятью аргументами сотрудника явно инициализирует переменные экземпляра, которые
        BasePlusCommissionEmployee наследуется от класса CommissionEmployee. Аналогично, класс
        Конструктор CommissionEmployee неявно вызывает конструктор объекта класса. Основа-
        Конструктор PlusCommissionEmployee должен делать это явно, поскольку CommissionEmployee
        не предоставляет конструктора без аргументов, который можно было бы вызвать неявно.
        Тестовый класс BasePlusCommissionEmployee
        Класс BasePlusCommissionEmployeeTest для этого примера идентичен классу BasePlusCommissionEmployeeTest.
        Рис. 9.7 и выдает тот же результат, поэтому мы его здесь не показываем. Хотя версия
        класса BasePlusCommissionEmployee на рис. 9.6 не использует наследование, а версия
        на рис. 9.9 использует, оба класса обеспечивают одинаковую функциональность. Исходный код на рис. 9.9 (47
        строк) значительно короче, чем на рис. 9.6 (116 строк), поскольку большая часть базы-
        Функциональность PlusCommissionEmployee теперь унаследована от CommissionEmployee—
        теперь существует только одна копия функциональности CommissionEmployee. Это делает код
        проще поддерживать, изменять и отлаживать, потому что код, связанный с комиссионером
        , существует только в классе CommissionEmployee.
        Примечания по использованию защищенных переменных экземпляра
        В этом примере мы объявили переменные экземпляра суперкласса защищенными, чтобы подклассы
        могли получить к ним доступ. Наследование защищенных переменных экземпляра немного повышает производительность,
        поскольку мы можем напрямую обращаться к переменным в подклассе, не вызывая накладных расходов на вызов метода set или get.
        Однако в большинстве случаев лучше использовать частные переменные экземпляра
        поощрять правильную разработку программного обеспечения и оставлять вопросы оптимизации кода
        компилятору. Ваш код будет легче поддерживать, изменять и отлаживать.
        Использование защищенных переменных экземпляра создает несколько потенциальных проблем. Во-первых, объект подкласса
        может устанавливать значение наследуемой переменной напрямую, не используя метод set. Поэтому
        объект подкласса может присвоить переменной недопустимое значение, возможно, оставив объект
        в несогласованном состоянии. Например, если бы мы объявили экземпляр CommissionEmployee
        переменная grossSales as protected, объект подкласса (например, BasePlusCommissionEmployee)
        затем можно было бы присвоить отрицательное значение валовым продажам. Другая проблема с использованием защищенных
        переменных экземпляра заключается в том, что методы подкласса, скорее всего, будут написаны так, что они будут зависеть
        от реализации данных суперкласса. На практике подклассы должны зависеть только от служб
        суперкласса (т. е. от непубличных методов), а не от реализации данных суперкласса.
        С помощью защищенных переменных экземпляра в суперклассе нам может потребоваться изменить все
        подклассы суперкласса, если реализация суперкласса изменяется. Например, если по
        какой-то причине мы изменим имена переменных экземпляра FirstName и LastName
        на first и last, то нам придется сделать это для всех вхождений, в которых подкласс
        напрямую ссылается на переменные экземпляра суперкласса FirstName и LastName. В таком случае
        программное обеспечение считается хрупким или хрупким, потому что небольшое изменение в суперклассе может
        “сломать” реализацию подкласса. Вы должны быть в состоянии изменить реализацию суперкласса
        в то же время предоставляя те же услуги подклассам. Конечно, если службы суперкласса
        изменяются, мы должны переопределить наши подклассы. Третья проблема заключается в том, что защищенные
        члены класса видны всем классам в том же пакете, что и класс, содержащий
        защищенные члены,—это не всегда желательно.вызова метода set или get. Однако в большинстве случаев лучше использовать частные переменные экземпляра
        , чтобы стимулировать правильную разработку программного обеспечения, и оставить вопросы оптимизации кода
        компилятору. Ваш код будет легче поддерживать, изменять и отлаживать.
        Использование защищенных переменных экземпляра создает несколько потенциальных проблем. Во-первых, объект подкласса
        может устанавливать значение наследуемой переменной напрямую, не используя метод set. Поэтому
        объект подкласса может присвоить переменной недопустимое значение, возможно, оставив объект
        в несогласованном состоянии. Например, если бы мы объявили переменную экземпляра
        CommissionEmployee grossSales защищенной, объект подкласса (например, BasePlusCommissionEmployee)
        затем можно было бы присвоить отрицательное значение валовым продажам. Еще одна проблема с использованием protected
переменные экземпляра - это то, что методы подкласса, скорее всего, будут написаны так, чтобы они зависели
        от реализации данных суперкласса. На практике подклассы должны зависеть только от служб
        суперкласса (т. е. от непубличных методов), а не от реализации данных суперкласса.
        С защищенными переменными экземпляра в суперклассе нам может потребоваться изменить все
        подклассы суперкласса, если реализация суперкласса изменится. Например, если по
        какой-то причине мы должны были изменить имена переменных экземпляра FirstName и LastName
        для первого и последнего, то мы должны были бы сделать это для всех вхождений, в которых подкласс
        непосредственно ссылается на переменные экземпляра суперкласса FirstName и LastName. В таком случае
        программное обеспечение считается хрупким или хрупким, потому что небольшое изменение в суперклассе может
        “сломать” реализацию подкласса. Вы должны быть в состоянии изменить реализацию суперкласса
        , все еще предоставляя те же услуги подклассам. Конечно, если службы суперкласса
        изменяются, мы должны переопределить наши подклассы. Третья проблема заключается в том, что класс защищен
        члены видны всем классам в том же пакете, что и класс, содержащий
        защищенные члены,—это не всегда желательно.*/
