package daytelsJava.polynorphism10;

public class PolymorphismTheory_Example {

}
/**
 * 10.3 Демонстрация Полиморфного Поведения
 * Раздел 9.4 создал иерархию классов, в которой класс BasePlusCommissionEmployee наследуется
 * от CommissionEmployee. Примеры в этом разделе манипулировали комиссией-
 * Объекты Employee и BasePlusCommissionEmployee, используя ссылки на них для
 * вызова своих методов—мы нацелили переменные суперкласса на объекты суперкласса и
 * переменные подкласса на объекты подкласса. Эти назначения являются естественными и простыми—
 * переменные суперкласса предназначены для ссылки на объекты суперкласса, а переменные подкласса предназначены
 * для ссылки на объекты подкласса. Однако, как вы скоро увидите, возможны и другие задания.
 * В следующем примере мы нацеливаем ссылку суперкласса на объект подкласса. Затем мы покажем
 * , как вызов метода на объекте подкласса через ссылку на суперкласс вызывает
 * функциональность подкласса—тип объекта, на который ссылается ссылка, а не тип переменной, определяет
 * , какой метод вызывается. Этот пример демонстрирует, что объект подкласса может рассматриваться
 * как объект его суперкласса, что позволяет проводить различные интересные манипуляции. Программа может
 * создайте массив переменных суперкласса, которые ссылаются на объекты многих типов подклассов. Это
 * допустимо, поскольку каждый объект подкласса является объектом своего суперкласса. Например, мы можем
 * присвоить ссылку объекта BasePlusCommissionEmployee суперклассу Commission-
 * Переменная Employee, поскольку BasePlusCommissionEmployee является CommissionEmployee—
 * мы можем рассматривать BasePlusCommissionEmployee как CommissionEmployee.
 * Как вы узнаете позже в этой главе, вы не можете рассматривать объект суперкласса как подкласс
 * объект, потому что объект суперкласса не является объектом ни одного из его подклассов. Например, мы
 * не можем присвоить ссылку объекта
 * CommissionEmployee переменной подкласса BasePlusCommissionEmployee, поскольку CommissionEmployee не является BasePlusCommission-
 * Employee—a CommissionEmployee не имеет переменной экземпляра
 * baseSalary и не имеет методов setBaseSalary и getBaseSalary. Отношение is-a применяется только
 * вверх по иерархии от подкласса к его прямым (и косвенным) суперклассам, а не наоборот
 * (т. е. Не вниз по иерархии от суперкласса к его подклассам).
 * Компилятор Java допускает присвоение ссылки суперкласса
 * переменной подкласса, если мы явно приведем ссылку суперкласса к типу подкласса—метод, который мы
 * обсуждаем в разделе 10.5. Зачем нам вообще выполнять такое задание?
 * Ссылка на суперкласс может использоваться для вызова только методов, объявленных в суперклассе—
 * попытка вызвать методы только подкласса через ссылку на суперкласс приводит к
 * ошибкам компиляции. Если программе необходимо выполнить специфичную для подкласса операцию над подклассом
 * объект, на который ссылается переменная суперкласса, программа должна сначала привести ссылку суперкласса
 * к ссылке подкласса с помощью метода, известного как нисходящая передача. Это позволяет
 * программе вызывать подклассы, которые не входят в суперкласс.Мы показываем
 * пример нисходящей трансляции в разделе 10.5.
 * Пример на рис. 10.1 демонстрирует три способа использования переменных суперкласса и подкласса
 * для хранения ссылок на объекты суперкласса и подкласса. Первые два просты—
 * как и в разделе 9.4, мы присваиваем ссылку суперкласса переменной суперкласса, а
 * ссылка подкласса на переменную подкласса. Затем мы демонстрируем связь между
 * подклассами и суперклассами (т. е. Отношение is-a), присваивая ссылку на подкласс
 * переменной суперкласса. Эта программа использует классы CommissionEmployee и BasePlusCommissionEmployee
 * из рис. 9.10 и рис. 9.11 соответственно.
 * На рис. 10.1 строки 10-11 создают объект CommissionEmployee и присваивают его ссылку
 * переменной CommissionEmployee. Строки 14-16 создают
 * объект BasePlusCommissionEmployee и присваивают его ссылку переменной BasePlusCommissionEmployee. Эти назначения
 *
 * Полиморфизм позволяет вам “программировать в общем”, а не “программировать в конкретном”.
 * В частности, полиморфизм позволяет вам писать программы, которые обрабатывают объекты, которые разделяют один и тот же суперкласс (прямо или косвенно),
 * как если бы все они были объектами суперкласса; это может упростить программирование.
 * Рассмотрим следующий пример полиморфизма. Предположим, мы создаем программу, которая имитирует движение нескольких видов животных для биологического исследования.
 * Классы Рыбы, Лягушки и Птицы представляют собой типы исследуемых животных.
 * Представьте себе, что каждый класс расширяет суперкласс Animal, который содержит метод move и поддерживает текущее местоположение животного в виде координат x-y.
 * Каждый подкласс реализует метод move. Наша программа поддерживает массив Животных, содержащий ссылки на объекты различных подклассов Животных.
 * Чтобы имитировать движения животных, программа посылает каждому объекту одно и то же сообщение один раз в секунду, а именно: "двигайся".
 * Каждый конкретный тип животных реагирует на сообщение о движении по—своему-рыба может плавать на три фута, Лягушка может прыгать на пять футов, а Птица может летать на десять футов.
 * Каждый объект знает, как изменить свои координаты x-y соответствующим образом для своего конкретного типа движения. Полагаться на то, что каждый объект знает,
 * как “сделать правильную вещь” (то есть сделать то, что подходит для данного типа объекта) в ответ на один и тот же вызов метода, - это ключевая концепция полиморфизма.
 * Одно и то же сообщение (в данном случае движение), отправленное различным объектам, имеет “много форм” результатов—отсюда и термин полиморфизм.
 * С помощью полиморфизма мы можем проектировать и реализовывать системы, которые легко расширяемы—новые классы могут быть добавлены практически без изменений к общим частям программы,
 * если новые классы являются частью иерархии наследования, которую программа обрабатывает в общем виде. Единственные части программы, которые должны быть изменены, - это те,
 * которые требуют непосредственного знания новых классов, которые мы добавляем в иерархию.
 * С помощью полиморфизма мы можем проектировать и реализовывать системы, которые легко расширяемы—новые классы могут быть добавлены практически без изменений к общим частям программы,
 * если новые классы являются частью иерархии наследования, которую программа обрабатывает в общем виде. Единственные части программы, которые должны быть изменены, - это те,
 * которые требуют непосредственного знания новых классов, которые мы добавляем в иерархию. Например, если мы расширим класс Animal, чтобы создать класс Tortoise (который может ответить
 * на сообщение о перемещении ползком один дюйм), нам нужно написать только класс Tortoise и ту часть симуляции, которая создает экземпляр объекта Tortoise. Части симуляции,
 * которые говорят каждому Животному двигаться в целом, могут оставаться неизменными.
 * Обзор главы
 * Сначала мы обсудим общие примеры полиморфизма. Затем мы приводим простой пример, демонстрирующий полиморфное поведение.
 * Мы используем ссылки на суперкласс для полиморфного манипулирования как объектами суперкласса, так и объектами подкласса.
 * Затем мы представляем примерное исследование, которое пересматривает иерархию сотрудников в разделе 9.4.5.
 * Мы разрабатываем простое приложение для расчета заработной платы, которое полиморфно вычисляет еженедельную зарплату нескольких различных типов сотрудников,
 * используя метод заработка каждого сотрудника. Хотя заработки каждого типа работников рассчитываются определенным образом, полиморфизм позволяет нам обрабатывать сотрудников “в целом”.
 * В данном примере мы расширяем иерархию, включив в нее два новых класса—наемных работников (для людей, получающих фиксированную еженедельную зарплату) и
 * часовых работников (для людей, получающих почасовую зарплату и “полтора часа” для сверхурочных).
 * Мы объявляем общий набор функций для всех классов обновленной иерархии в “абстрактном” классе Employee, от которого “конкретные”классы SalariedEmployee,
 * HourlyEmployee и CommissionEmployee наследуются непосредственно, а “конкретный” класс BasePlusCommissionEmployee наследуется косвенно. Как вы скоро увидите,
 * когда мы вызываем метод заработка каждого сотрудника из ссылки на сотрудника суперкласса, выполняется правильный расчет подкласса заработка, благодаря полиморфным возможностям Java.
 * Программирование в специфическом. Иногда при выполнении полиморфной обработки нам нужно программировать “в специфическом”. Наш пример сотрудника показывает, что программа может
 * определить тип объекта во время выполнения и действовать на этот объект соответствующим образом. В данном случае мы решили,
 * что сотрудники Basepluscommission должны получать 10% - ную прибавку к своей базовой зарплате. Таким образом, мы используем эти возможности, чтобы определить,
 * является ли конкретный объект сотрудника БазойPlusCommissionEmployee. Если это так, то мы увеличиваем базовую зарплату этого сотрудника на 10%.
 * Интерфейсы
 * Глава продолжается введением в Java-интерфейсы. Интерфейс описывает набор методов, которые могут быть вызваны на объекте, но не предоставляет конкретных реализаций для всех методов.
 * Вы можете объявить классы, которые реализуют (т. е. Предоставляют конкретные реализации для методов) один или несколько интерфейсов.
 * Каждый метод интерфейса должен быть объявлен во всех классах, которые явно реализуют интерфейс. Как только класс реализует интерфейс, все объекты этого класса имеют связь с типом интерфейса, и все
 * объекты класса гарантированно обеспечивают функциональность, описываемую интерфейсом. Это справедливо и для всех подклассов этого класса.
 * Интерфейсы особенно полезны для назначения общих функций возможно несвязанным классам. Это позволяет обрабатывать объекты несвязанных классов полиморфно—объекты классов,
 * реализующих один и тот же интерфейс, могут отвечать на все вызовы методов интерфейса. Чтобы продемонстрировать создание и использование интерфейсов, мы модифицируем наше приложение
 * расчета заработной платы, чтобы создать приложение общей кредиторской задолженности, которое может вычислять платежи, причитающиеся сотрудникам компании, и суммы счетов-фактур,
 * подлежащие выставлению счетов за приобретенные товары. Как вы увидите, интерфейсы обеспечивают полиморфные возможности, подобные тем, которые возможны при наследовании.
 * 10.2 Примеры полиморфизма
 * Теперь рассмотрим несколько дополнительных примеров полиморфизма.
 * Четырехугольники
 * Если класс Rectangle является производным от класса Quadrilateral, то объект Rectangle является более конкретной версией Четырехугольника. Любая операция (например, вычисление периметра или
 * площади), которая может быть выполнена на Четырехугольнике, также может быть выполнена на Прямоугольнике.
 * Эти операции также могут быть выполнены на других Четырехугольниках, таких как квадраты, Параллелограммы
 * и трапеции. Полиморфизм возникает, когда программа вызывает аметод
 * через четырехугольную переменную суперкласса—во время выполнения вызывается правильная
 * версия подкласса метода, основанная на типе ссылки, хранящейся в переменной суперкласса
 * Вы увидите простой пример кода, который иллюстрирует этот процесс в разделе 10.3.
 * Космические объекты в видеоигре
 * Предположим, мы создаем видеоигру, которая манипулирует объектами классов Марсианский, Венерианский, плутонианский,
 * космический корабль и лазерный луч. Представьте, что каждый класс наследуется от суперкласса SpaceObject,
 * который содержит метод draw. Каждый подкласс реализует этот метод. Экран
 * менеджер поддерживает коллекцию (например, массив SpaceObject) ссылок на объекты различных
 * классов. Чтобы обновить экран, экранный менеджер периодически посылает каждому объекту одно и то же
 * сообщение—а именно, draw. Однако каждый объект реагирует по-своему, исходя из своего класса.
 * Например, марсианский объект может нарисовать себя красным с зелеными глазами и соответствующим количеством
 * антенн. Космический корабль может изобразить себя в виде яркой серебристой летающей тарелки. Объект лазерного
 * луча может нарисовать себя в виде ярко - красного луча на экране. Опять то же самое
 * сообщение (в данном случае draw), отправленное на различные объекты, имеет “много форм” результатов.
 * Менеджер экрана может использовать полиморфизм для облегчения добавления новых классов в систему
 * с минимальными изменениями кода системы. Предположим, что мы хотим добавить меркурианские
 * объекты в нашу видеоигру. Для этого мы построим класс Mercurian, который расширяет SpaceObject
 * и предоставляет собственную реализацию метода draw. Когда объекты Mercurian появляются
 * в коллекции SpaceObject, код диспетчера экрана вызывает метод draw точно так же, как он
 * делает это для каждого другого объекта в коллекции, независимо от его типа. Таким образом, новые объекты
 * Mercurian просто “подключаются” без каких-либо изменений кода диспетчера экрана программистом.
 * Таким образом, без модификации системы (кроме создания новых классов и
 * модификации кода, создающего новые объекты) можно использовать полиморфизм для удобного
 * включения дополнительных типов, которые не были предусмотрены при создании системы.
 */

