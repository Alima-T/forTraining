package Fedor.les02_20Casting;

public class CastingTests {
    public static void main(String[] args) {
/*Widening (automatically) - расширение типа от меньшего к большему происходит автоматически без потери информации.
При этом сначала производится преобразование (расширение) потом действие (сложение) */
        byte a = 5;
        short b = a;
        int c = a + b; //сначала a расширяется до long, потом происходит сложение
        long d = c * c;
        System.out.println(d);
        System.out.println();

/*Числа с плавающей точкой. Если в выражении участвуют целое число и число с плавающей точкой (float/double),
целое число будет преобразовано в число с плавающей точкой (float/double), и только потом будет выполнена операция над ними.
Если в операции участвуют float и double, то float будет преобразован к double.
Переменной типа float можно присвоить переменную любого целочисленного типа. Даже типа long, длина которого 8 байт.
А переменной типа double можно присвоить вообще что угодно: переменную любого целочисленного типа и переменную типа float:*/
        long a1 = 1234567890;//
        float b1 = a1;
        double c1 = a1;
        System.out.println(b1);
        System.out.println(c1);
 /*Narrowing (manually) сужение типа - преобразование от типа большего размера к меньшему — называют сужением типа.
 При сужении типа мы должны явно показать компилятору, что мы не ошиблись, и отбрасывание части числа сделано осознанно.
 Для этого используется оператор приведения типа. Это имя типа в круглых скобках: (тип) выражение.
 В таких ситуациях Java-компилятор требует от программиста указывать оператор преобразования типа.*/
        //В первом случае 1 умещается вовсех типах, код скомпилируется без потерь:
        long a2 = 1;
        int b2 = (int) a2;

        short c2 = (short) b2;
        byte d2 = (byte) c2;
        //Во втором случае 1000000 умещается только в типах long и int
        // В short и byte  произойдет приведение с потерей информации, т.к. все значение не умещается в разрядность типов
        long a3 = 1000000;
        int b3 = (int) a3;
        short c3 = (short) b3;
        byte d3 = (byte) c3;
        System.out.println(a3);
        System.out.println(b3);
        System.out.println(c3);
        System.out.println(d3);

 /*Типы byte, short, char ВСЕГДА ПРЕОБРАЗОВЫВАЮТСЯ в int при взаимодействии между собой.
 Если умножить byte на short, будет int. Если умножить byte на byte, будет int. Даже если сложить byte и byte, будет int. */
        byte a4 = 110;
        byte b4 = 120;
        // byte c4 = a4 * b4;   // ОШИБКА  110 * 120 будет 13,200, что несколько больше, чем максимальное значение типа byte: 127
        byte a5 = 110;
        byte b5 = 20;
        // byte c5 = a5 - b5;   // ОШИБКА 110 - 20 будет 90,  число в пределах максимального значение типа byte: 127, кроме того мы вычитаем,
        // но все равно ошибка, тк.к есть правило ВСЕ операции с целыми типами, меньшими чем int, всегда сразу преобразовываются в тип int.
        int c5 = a5 + b5;
/* ВСЕ операции с целыми типами, меньшими чем int, всегда сразу преобразовываются в тип int.
И поэтому если хотим сохранить результат вычисления в переменную типа, меньше чем int, всегда нужно будет явно указывать операцию приведения типа. */
        byte a6 = 110;
        byte b6 = 120;
        byte c6 = (byte) (a6 * b6); //        выражение byte * byte будет иметь тип int
        byte a7 = 110;
        byte b7 = 120;
        byte c7 = (byte) (a7 + b7); //        выражение byte + byte будет иметь тип int
        byte a8 = 1;
        a8 += 2;
        byte b8 = (byte) (a8 + 2);//    выражение byte + int будет иметь тип int,т.к. единица – это литерал типа int.
/*5. Важный нюанс. Операция приведения типа имеет довольно высокий приоритет.
Поэтому если в выражении есть, допустим, сложение и операция приведения типа, она будет выполнена до сложения.*/
        byte a9 = 1;
        byte b9 = 2;
//byte c9 = (byte) a9 * b9; // ОШИБКА Оператор приведения типа будет применен только к переменной a, которая и так имеет тип byte. Код не скомпилируется.
        byte a10 = 1;
        byte b10 = 2;
        byte c10 = (byte) (a10 * b10); //Правильно! Если необходимо преобразовать к определенному типу все выражение,
// а не только один его элемент, то нужно обернуть все выражение в круглые скобки и перед ними поставить оператор приведения типа.

/*Тип char, как и тип short, занимает два байта, но для их преобразования в друг друга всегда нужно использовать оператор приведения типа.
Все дело в том, что тип short знаковый, и может содержать значения от -32,768 до +32,767, а тип char беззнаковый, и может содержать значения от 0 до 65,535.
В char нельзя сохранить отрицательные числа, которые могут храниться в short. А в short нельзя сохранить числа больше 32,767, которые могут храниться в char.*/


    }
}
